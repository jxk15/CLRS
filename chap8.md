---
title: 第 8 章 线性时间排序 Exercises & Problems
---

## Exercises

## 8.1 排序算法的下界

1. $n-1$。此时 $\pi(i)=i$，只需 $n-1$ 次 $i:i+1$。

2. 由附录 A.11，得

    $$
    \begin{aligned}
    \int_0^{n}\lg (x) dx &\le \sum_{k=1}^{n}\lg k \le \int_{1}^{n+1}\lg(x)dx \\
    \dfrac{n\ln n-n}{\ln 2} &\le \sum_{k=1}^{n}\lg k \le \dfrac{(n+1)\ln (n+1)-n}{\ln 2}
    \end{aligned}
    $$

    ??? 或者
        $$
        \begin{aligned}
        \sum_{k=1}^n\lg k &\le \sum_{k=1}^n\lg n  \\
        &= n\lg n
        \end{aligned}
        $$

        $$
        \begin{aligned}
        \sum_{k=1}^n\lg k &= \sum_{k=1}^{n/2}\lg k + \sum_{k=n/2+1}^n \lg k \\
        &\ge \sum_{k=1}^{n/2}1 + \sum_{k=n/2+1}^n \lg \dfrac{n}{2} \\
        &= \dfrac{n}{2} + \dfrac{n}{2}\lg \dfrac{n}{2}  \\
        &= \dfrac{n}{2}\lg n
        \end{aligned}
        $$


3. 假设叶结点数量为 $n!/2$，套用定理 8.1 的证明过程，得 $h=\Omega(n\lg n)$。对于 $\dfrac{1}{n},\dfrac{1}{2^n}$ 同理。

4. 由于共有 $n/k$ 个子序列，每个子序列含 $k$ 个元素，所以叶结点至少为 $(k!)^{n/k}$。设树高为 $h$，得

    $$
    \begin{aligned}
    2^h &\ge (k!)^{n/k} \\
    h &\ge \dfrac{n}{k}\lg k! \\
    h &\ge \dfrac{n}{k}k\lg k = n\lg k
    \end{aligned}
    $$

## 8.2 计数排序

1. 略。
2. 由于书中 $\text{COUNTING-SORT}$ 第 10 行是按下标从大到小遍历，且在为数组 B 赋值后 $C[A[j]]$ 的值减一，不会再增加，所以遇到下标更小的相同元素时，其在数组 B 中的下标也一定更小。
3. 计数排序对元素在数组 A 中的下标无要求，所以以任意顺序遍历数组 A 都对算法正确性无影响。分析过程同上，不再稳定。
4. $[a..b]=[1..b]-[1..a-1]$。$\text{COUNTING-SORT}$ 的 1~9 行已求出 $[1..i]$ 内的元素数量。

## 8.3 基数排序

1. 略。

2. 插入排序、归并排序是稳定的。

    把数组中的元素替换为含该元素及其下标的二元组，然后进行比较。

    额外时间开销：生成二元组需要的时间为 $\Theta(n)$；每次比较操作的时间提升常数倍。

    额外空间开销：多存储 $n$ 个下标，

3. **循环不变量**：在第 i 次迭代前，数组中的元素已按低 $i-1$ 位排序。

    **初始**：$i=1$，显然成立。

    **保持**：在第 $i$ 次迭代中，对元素的第 $i$ 位排序。对任意的两个元素 $a,b$，

       - 假设 $a$ 的第 $i$ 位大于 $b$ 的第 $i$ 位，排序后元素 $a$ 的下标更大，满足按低 $i$ 位排序。
       - 假设 $a$ 的第 $i$ 位等于 $b$ 的第 $i$ 位，设排序前 $a$ 的下标更小，由循环不变量知 $a$ 的低 $i-1$ 位更小。由于选择的排序具有稳定性，所以排序后 $a$ 的下标仍然更小，满足按低 $i$ 位排序。
       - 然后 $i$ 递增 1，循环不变量保持。

    **终止**：$i=d+1$，数组中的元素按低 $d$ 位排序，由于元素最多为 $d$ 位，所以数组已有序。

    用到排序的稳定性：当元素的第 $i$ 位相同时。

4. 将输入的 n 个整数转换为 n 进制数，则每个元素的位数不超过 3。然后使用书中的基数排序，时间复杂度为 $\Theta(3(n+n))=\Theta(n)$。

5. 最坏情况下递归树为完全 10 叉树，树的高度为 $d$。排序次数为 $\displaystyle\sum_{i=0}^{d-1}10^i$ 。

    叶结点可直接作为最终结果的一部分，不属于临时保存的。对于内部结点，产生的 10 个子结点中只有一个进入下一轮排序，其他 9 堆需要临时保存，等第一堆排完后再排。所以需要临时保存的卡片有 $\displaystyle\sum_{i=1}^{d-1}9^i$。

## 8.4 桶排序

1. 略。

2. 所有的数据被分配到一个桶中且桶中数据为逆序。

    对桶内数据排序时使用归并排序或堆排序。

3. 如下：

    $$
    \begin{aligned}
    E[X] &= 2\times \dfrac{1}{4} + 1\times\dfrac{1}{2} + 0\times\dfrac{1}{4} = 1\\
    E[X^2] &= 4\times \dfrac{1}{4} + 1\times\dfrac{1}{2} + 0\times\dfrac{1}{4} = 1.5\\
    E^2[X] &= 1
    \end{aligned}
    $$

4. 为了使元素等可能地出现在任一桶中，可以构造 $n$ 个等面积的圆环作为桶。最内部的圆环内半径为 0。所以从内到外第 $i$ 个圆环的外半径 $r_{i1}$ 为 $r_{i1}^2\pi=\dfrac{i}{n}\pi$，内半径 $r_{i2}$ 为 $r_{i2}^2\pi=\dfrac{i-1}{n}\pi$，$1\le i \le n$。（$r_{11}=\dfrac{\pi}{n},r_{12}=0$）

5. 使用桶排序。定义 $n$ 个桶：$[p_0,p_1),[p_1,p_2),..,[p_{n-1},p_n)$。其中 $P(p_i)=\dfrac{i}{n}$。所以随机变量落入每个桶内的概率均为 $\dfrac{1}{n}$。

## Problems

1. 比较排序的概率下界

    1. 由于算法是确定的，所以输入数据和叶结点一一对应，所以可达的叶结点有 $n!$ 个。其他叶结点不可达，概率为 0。

        由于输入随机，所以等可能地对应到 $n!$ 种结果，即概率为 $\dfrac{1}{n!}$。

    2. 由于 $T$ 与 $LT,RT$ 之间都存在一条边，所以 $LT,RT$ 中所有叶结点的深度都比在 $T$ 中时的深度少 1。因为 $LT,RT$ 中共有 $k$ 个叶结点，所以 $D(T)=D(LT)+D(RT)+k$。

    3. 由于决策树是满二叉树且 $k>1$，得 $1\le i_0\le k-1$，

        $$
        \begin{aligned}
        d(k) = \min (D(T)) &= \min{(D(LT)+D(RT)+k)} \\\\
        &= \min(\min_{1\le i\le k-1}(d(i)+d(k-i))+k) \\\\
        &= \min_{1\le i\le k-1}(d(i)+d(k-i)+k)
        \end{aligned}
        $$

    4. $\min_{1\le i\le k-1}i\lg i+(k-i)\lg (k-i)=k\lg k-k$：证明略。

        假设 $d(k)\ge k\lg k$，代入上一小题即得 $d(k)=\Omega(k\lg k)$。

    5. $D(T_A)\ge d(n!)$，所以 $D(T_A)=\Omega(n!\lg (n!))$。

        平均运行时间：$\dfrac{\Omega(n!\lg(n!))}{n!}=\Omega(\lg(n!))=\Omega(n\lg n)$。

    6. 可以通过删除“随机化”结点的平均比较次数较多的子结点来得到一个确定性决策树。

2. 线性时间原址排序

    1. 计数排序

    2. 快速排序中的 $\rm{PARTITION}$

    3. 插入排序

    4. $\rm{RADIX-SORT}$ 用到的基础排序方法需要满足：稳定、时间复杂度为 $O(n)$。

        - (1) 满足
        - (2) 不稳定
        - (3) 时间复杂度不满足

    5. 伪代码如下。$C[i]$ 的值为 $i$ 的个数。（很多人把这个当成桶排序）

        不稳定：因为 $C[i]$ 仅记录了元素的数量。

        ```
        // A[1..n], A.length = n
        CountingSort(A, k)
            let C[0..k] be a new array
            for i=0 to k
                C[i] = 0
            for i=1 to A.length
                C[A[i]] = C[A[i]] + 1
            for i=0,j=1 to k
                while C[i] > 0
                    A[j] = C[i]
                    j = j + 1
                    C[i] = C[i] - 1
        ```

3. 变长数据项的排序

    1. 遍历数组，将不同位数的元素分开，对相同位数的元素使用基数排序。然后按位数从低到高把所有元素合并。

        假设有 $m$ 个正整数，$A[i]$ 表示位数为 $i$ 的整数个数，$B[i]$ 表示第 $i$ 个数的位数。使用计数排序把不同位数的元素分开，时间为 $O(n)$。单个元素的位数不超过 $n$，所以基数排序的总时间为 $\displaystyle\sum_{i=1}^n O(iA[i])=O(n)$。

    2. 使用计数排序对首字母排序，把字符串数组分成若干个区间。然后对每个区间向下递归，对区间内字符串的第 $i,2\le i$ 个字母排序（空字母小于 $a$，即 $a<aa$）。正确性证明略。

        设有 $m$ 个字符串，$A[i]$ 表示第 $i$ 个字符串中字母个数。易知对第 $A[i] + 1$ 个字母排序时，可以确定该字符串的位置，所以时间复杂度为 $\displaystyle\sum_{i=1}^{m}1+A[i]=m+n=O(n)$。

4. 水壶

    1. 遍历所有的蓝色水壶，把选到的蓝色水壶与所有的红色水壶比较。

    2. 使用决策树，为了配对，该树为三叉树，对应小于、大于、等于三种情况。设树的高度 $h$，至少有 $n!$ 个叶结点，$3^h\ge n!$，所以 $h=\Omega(n\lg n)$。

    3. 思路类似与快排。随机从蓝色水壶中选一个，所有红色水壶比较，则可以得到一个配对并把红色水壶分为盛水量更大更小的两个部分。再使用配对的红色水壶把蓝色水壶分为盛水量更大更小的两个部分。然后对两个部分递归。

        分析：与快排的分析相同。所以期望时间为 $O(n\lg n)$，最坏为 $O(n^2)$。

5. 平均排序

6. 合并有序列表的下界。设两个待合并列表分别为 $A,B$，合并后的列表为 $C$。

    1. $\dbinom{2n}{n}$

    2. 套用 8.1 节的方法和练习 8.1-2，得

        $$
        \begin{aligned}
        2^h &\ge \dbinom{2n}{n} \\
        h &\ge \lg \dfrac{(2n)!}{(n!)^2} \\
        &= \lg((2n)!) - 2\lg{(n!)} \\
        &= \sum_{k=1}^{2n}\lg k - 2\sum_{k=1}^{n}\lg k  \\
        &\ge \dfrac{2n\ln(2n)-2n}{\ln2} - 2\dfrac{(n+1)\ln(n+1)-n}{\ln2} \\
        &= 2n + 2n\lg\dfrac{n}{n+1}-2\lg(n+1) \\
        &= 2n - o(n)
        \end{aligned}
        $$

    3. 设合并后 $a,b$ 连续且 $a < b$，$a$ 来自列表 $A$，$b$ 来自列表 $B$。则在 $a$ 加入列表 $C$ 之前，列表 $A$ 中所有比 $a$ 小的数和列表 $B$ 中所有比 $b$ 小的数一定已加入列表 $C$，所以此时 $a,b$ 分别是其所在列表中的最小值，一定发生比较。

    4. 设列表 $A=<1,3,5,..,2n-1>,B=<2,4,6,..,2n>$，由第三小题知我们必须比较 1 和 2，2 和 3，直到比较 $2n-1$ 和 $2n$。比较次数为 $2n-1$。又因为下界为 $2n-o(n)$，所以 $2n-1$ 是一个紧确界。

7. 01 排列引理和列排序
